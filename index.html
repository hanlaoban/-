<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Christmas AR - v2.0</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        
        /* 容器布局 */
        #container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
        
        /* 1. 摄像头背景 (底层) - 镜像翻转 */
        #video-feed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; filter: grayscale(100%) contrast(1.2) brightness(0.6); z-index: 0; transform: scaleX(-1); }
        
        /* 2. 手部骨骼绘制层 (中间层) - 镜像翻转以匹配视频 */
        #skeleton-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; pointer-events: none; transform: scaleX(-1); }

        /* 3. Three.js 3D 粒子层 (顶层) */
        #three-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }

        /* UI HUD */
        #ui-layer { position: absolute; top: 20px; left: 20px; color: white; z-index: 10; pointer-events: none; }
        .hud-text { font-size: 12px; letter-spacing: 1px; line-height: 1.5; text-shadow: 0 0 5px rgba(0, 255, 255, 0.5); color: #0ff; }
        .title { font-size: 24px; font-weight: bold; border-bottom: 2px solid #0ff; display: inline-block; margin-bottom: 10px; color: #fff; }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #0f0; font-size: 20px; z-index: 20; text-shadow: 0 0 10px #0f0; font-weight: bold; }
        
        /* GUI Container - 强制不可折叠样式 */
        #gui-container { position: absolute; top: 20px; right: 20px; z-index: 100; }
        /* 隐藏 lil-gui 的关闭按钮并禁止点击标题栏折叠 */
        .lil-gui .title { pointer-events: none; cursor: default; }
        .lil-gui .close-button { display: none; }
        .lil-gui { --background-color: rgba(0, 0, 0, 0.8); --text-color: #0ff; --title-background-color: #003333; --widget-color: #444; --hover-color: #666; --focus-color: #0ff; border: 1px solid #0ff; }
    </style>
    
    <!-- Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <!-- MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <!-- lil-gui -->
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
</head>
<body>

    <div id="container">
        <video id="video-feed" playsinline></video>
        <canvas id="skeleton-canvas"></canvas>
        <div id="three-canvas"></div>
    </div>

    <div id="loading">SYSTEM INITIALIZING...<br><span style="font-size:12px; color:#fff">Camera Access Required</span></div>

    <div id="ui-layer">
        <div class="title">PROJECT: XMAS_CORE_V2</div>
        <div class="hud-text">
            STATUS: <span id="status">SCANNING...</span><br>
            PARTICLES: 15,000<br>
            GESTURE: <span id="gesture-display">NONE</span><br>
            MODEL: <span id="model-name">TREE</span>
        </div>
    </div>
    
    <div id="gui-container"></div>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const CONFIG = {
            particleCount: 15000, // Reduced to 15,000
            particleSize: 0.18,   // Slightly larger since there are fewer
            glowIntensity: 0.8,
            repulseRadius: 2.0,
            repulseStrength: 5.0,
            rotationSpeed: 0.5,
            explosionForce: 0.0,
            colors: [
                new THREE.Color(0x00ff00), // Neon Green
                new THREE.Color(0xff0044), // Neon Red
                new THREE.Color(0xffffff), // Bright White
                new THREE.Color(0x00ffff)  // Cyber Cyan
            ]
        };

        // --- Global Variables ---
        let scene, camera, renderer, particles, material, geometry;
        let skeletonCtx, skeletonCanvas;
        let currentShapeIndex = 0;
        let time = 0;
        let isExploding = false;
        let explosionTime = 0;
        
        // Interaction States
        let isPinching = false;
        let isFist = false;
        let prevFist = false;
        let handPosition = new THREE.Vector3(999, 999, 999);

        const shapeNames = ["TREE", "SNOWMAN", "GIFT", "ANTLERS", "CANDY_CANE"];

        // --- Initialization ---
        async function init() {
            const container = document.getElementById('three-canvas');
            
            // 1. Scene Setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // 2. 2D Skeleton Canvas Setup
            skeletonCanvas = document.getElementById('skeleton-canvas');
            skeletonCtx = skeletonCanvas.getContext('2d');
            resizeCanvas();

            // 3. Particles
            createParticles();

            // 4. GUI
            setupGUI();

            // 5. MediaPipe Setup
            const videoElement = document.getElementById('video-feed');
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 1280,
                height: 720
            });
            cameraUtils.start();

            document.getElementById('loading').style.display = 'none';
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // --- 2D Skeleton Visualization ---
        function drawSkeleton(landmarks) {
            // Clear previous frame
            skeletonCtx.clearRect(0, 0, skeletonCanvas.width, skeletonCanvas.height);
            
            // Draw Connectors (Bones)
            drawConnectors(skeletonCtx, landmarks, HAND_CONNECTIONS, {
                color: '#00ffff', // Cyan bones
                lineWidth: 2
            });

            // Draw Landmarks (Joints)
            drawLandmarks(skeletonCtx, landmarks, {
                color: '#ffffff',
                fillColor: '#000000',
                lineWidth: 1,
                radius: 3
            });
        }

        function resizeCanvas() {
            skeletonCanvas.width = window.innerWidth;
            skeletonCanvas.height = window.innerHeight;
        }

        // --- Particle System ---
        function createParticles() {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const targets = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);
            const sizes = new Float32Array(CONFIG.particleCount);
            const randoms = new Float32Array(CONFIG.particleCount);

            for(let i=0; i<CONFIG.particleCount; i++) {
                // Initial random dispersion
                positions[i*3] = (Math.random() - 0.5) * 15;
                positions[i*3+1] = (Math.random() - 0.5) * 15;
                positions[i*3+2] = (Math.random() - 0.5) * 15;
                
                randoms[i] = Math.random();
                sizes[i] = Math.random();

                const c = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
                colors[i*3] = c.r;
                colors[i*3+1] = c.g;
                colors[i*3+2] = c.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('target', new THREE.BufferAttribute(targets, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uPixelRatio: { value: renderer.getPixelRatio() },
                    uSize: { value: CONFIG.particleSize * 50 },
                    uHandPos: { value: new THREE.Vector3(999,999,999) },
                    uRepulseRadius: { value: CONFIG.repulseRadius },
                    uRepulseStrength: { value: CONFIG.repulseStrength },
                    uExplosion: { value: 0.0 }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uPixelRatio;
                    uniform float uSize;
                    uniform vec3 uHandPos;
                    uniform float uRepulseRadius;
                    uniform float uRepulseStrength;
                    uniform float uExplosion;

                    attribute vec3 target;
                    attribute vec3 color;
                    attribute float aRandom;
                    attribute float size;

                    varying vec3 vColor;
                    varying float vAlpha;

                    // Noise Function
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                    float snoise(vec3 v) { 
                        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                        vec3 i  = floor(v + dot(v, C.yyy) );
                        vec3 x0 = v - i + dot(i, C.xxx) ;
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min( g.xyz, l.zxy );
                        vec3 i2 = max( g.xyz, l.zxy );
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;
                        i = mod289(i); 
                        vec4 p = permute( permute( permute( 
                                    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                                + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                                + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                        float n_ = 0.142857142857; 
                        vec3  ns = n_ * D.wyz - D.xzx;
                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z); 
                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_ ); 
                        vec4 x = x_ *ns.x + ns.yyyy;
                        vec4 y = y_ *ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);
                        vec4 b0 = vec4( x.xy, y.xy );
                        vec4 b1 = vec4( x.zw, y.zw );
                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));
                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                        vec3 p0 = vec3(a0.xy,h.x);
                        vec3 p1 = vec3(a0.zw,h.y);
                        vec3 p2 = vec3(a1.xy,h.z);
                        vec3 p3 = vec3(a1.zw,h.w);
                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                        p0 *= norm.x;
                        p1 *= norm.y;
                        p2 *= norm.z;
                        p3 *= norm.w;
                        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                                    dot(p2,x2), dot(p3,x3) ) );
                    }

                    void main() {
                        vColor = color;
                        vec3 pos = target; 

                        // 1. Repulsion
                        float dist = distance(pos, uHandPos);
                        if (dist < uRepulseRadius && uHandPos.x < 900.0) {
                            vec3 dir = normalize(pos - uHandPos);
                            float force = (1.0 - dist / uRepulseRadius) * uRepulseStrength;
                            pos += dir * force;
                        }

                        // 2. Explosion
                        if (uExplosion > 0.01) {
                            vec3 noiseVec = vec3(
                                snoise(vec3(pos.x, uTime, 0.0)),
                                snoise(vec3(pos.y, uTime, 1.0)),
                                snoise(vec3(pos.z, uTime, 2.0))
                            );
                            pos += noiseVec * uExplosion * 6.0;
                        }

                        // 3. Float
                        pos.y += sin(uTime * 2.0 + aRandom * 10.0) * 0.05;

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        gl_PointSize = uSize * size * (10.0 / -mvPosition.z) * uPixelRatio;
                        
                        vAlpha = 0.8 + 0.2 * sin(uTime * 10.0 + aRandom * 100.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vAlpha;

                    void main() {
                        vec2 uv = gl_PointCoord.xy - 0.5;
                        float r = length(uv);
                        if (r > 0.5) discard;
                        float glow = 1.0 - (r * 2.0);
                        glow = pow(glow, 2.0);
                        gl_FragColor = vec4(vColor * 1.8, vAlpha * glow);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            generateShape(0);
        }

        function generateShape(index) {
            const positions = particles.geometry.attributes.target.array;
            const count = CONFIG.particleCount;

            for(let i=0; i<count; i++) {
                let x, y, z;
                const theta = Math.random() * Math.PI * 2;
                const p = i * 3;

                if (index === 0) { // Tree
                    const h = Math.random() * 4 - 2;
                    const radius = (2 - h) * 0.4 * Math.sqrt(Math.random()); 
                    x = Math.cos(theta) * radius;
                    z = Math.sin(theta) * radius;
                    y = h;
                    if (Math.random() > 0.85) { x *= 1.2; z *= 1.2; } // Sparse outer
                } else if (index === 1) { // Snowman
                    const s = Math.random();
                    let cy, cr;
                    if (s < 0.45) { cy = -1.2; cr = 1.1; }
                    else if (s < 0.8) { cy = 0.5; cr = 0.8; }
                    else { cy = 1.8; cr = 0.5; }
                    const phi = Math.acos(2 * Math.random() - 1);
                    const rad = cr * Math.cbrt(Math.random());
                    x = rad * Math.sin(phi) * Math.cos(theta);
                    y = rad * Math.sin(phi) * Math.sin(theta) + cy;
                    z = rad * Math.cos(phi);
                } else if (index === 2) { // Gift
                    const w = 1.2;
                    x = (Math.random()-0.5)*2*w;
                    y = (Math.random()-0.5)*2*w;
                    z = (Math.random()-0.5)*2*w;
                    if(Math.random()>0.5) { // Shell logic
                        const axis = Math.floor(Math.random()*3);
                        if(axis===0) x = x>0?w:-w;
                        else if(axis===1) y = y>0?w:-w;
                        else z = z>0?w:-w;
                    }
                } else if (index === 3) { // Antlers
                    const t = Math.random() * Math.PI;
                    const side = Math.random() > 0.5 ? 1 : -1;
                    x = side * (Math.sin(t) * 1.5 + Math.sin(t*3)*0.5);
                    y = -1.5 + t * 3.0;
                    z = Math.cos(t) * 0.5 + (Math.random()-0.5)*0.2;
                    x += (Math.random()-0.5)*0.2;
                } else { // Candy Cane
                    const t = Math.random() * 5;
                    const thick = 0.3;
                    if (t < 3.5) { x = 0; y = t - 2; z = 0; } 
                    else {
                        const ang = (t - 3.5) * Math.PI * 1.2;
                        x = -0.6 * (1 - Math.cos(ang));
                        y = 1.5 + 0.6 * Math.sin(ang);
                        z = 0;
                    }
                    x += (Math.random()-0.5)*thick;
                    y += (Math.random()-0.5)*thick;
                    z += (Math.random()-0.5)*thick;
                }
                positions[p] = x;
                positions[p+1] = y;
                positions[p+2] = z;
            }
            particles.geometry.attributes.target.needsUpdate = true;
            document.getElementById('model-name').innerText = shapeNames[index];
        }

        // --- MediaPipe & Interaction ---
        function onHandsResults(results) {
            // 2D Skeleton Drawing
            skeletonCtx.save();
            skeletonCtx.clearRect(0, 0, skeletonCanvas.width, skeletonCanvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Draw 2D Skeleton
                drawConnectors(skeletonCtx, landmarks, HAND_CONNECTIONS, {color: '#00ffff', lineWidth: 2});
                drawLandmarks(skeletonCtx, landmarks, {color: '#ffffff', lineWidth: 1, radius: 2});
                
                document.getElementById('status').innerText = "LINK ESTABLISHED";
                document.getElementById('status').style.color = "#0ff";

                // 3D Interaction Mapping
                const ndcX = (1.0 - landmarks[8].x) * 2 - 1; 
                const ndcY = -(landmarks[8].y * 2 - 1);
                const vector = new THREE.Vector3(ndcX, ndcY, 0.5);
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const dist = -camera.position.z / dir.z;
                const pos = camera.position.clone().add(dir.multiplyScalar(dist));
                handPosition.copy(pos);

                detectGestures(landmarks);
            } else {
                handPosition.set(999, 999, 999);
                document.getElementById('status').innerText = "SEARCHING...";
                document.getElementById('status').style.color = "#fff";
                document.getElementById('gesture-display').innerText = "NONE";
                isPinching = false;
            }
            skeletonCtx.restore();
        }

        function detectGestures(lm) {
            const dist = (i1, i2) => Math.sqrt(Math.pow(lm[i1].x-lm[i2].x,2) + Math.pow(lm[i1].y-lm[i2].y,2) + Math.pow(lm[i1].z-lm[i2].z,2));
            const dTipWrist = dist(8, 0) + dist(12, 0) + dist(16, 0) + dist(20, 0);
            isFist = dTipWrist < 0.8;

            if (isFist && !prevFist) triggerExplosion();
            prevFist = isFist;

            isPinching = dist(4, 8) < 0.05;

            let text = "HOVER";
            if (isFist) text = "FIST [EXPLODE]";
            else if (isPinching) text = "PINCH [ROTATE]";
            document.getElementById('gesture-display').innerText = text;

            if (isPinching && particles) {
                const speed = (lm[8].x - 0.5) * 8.0; 
                particles.rotation.y += speed * 0.1;
            } else {
                particles.rotation.y += 0.002;
            }
        }

        function triggerExplosion() {
            if (isExploding) return;
            isExploding = true;
            explosionTime = 0;
            setTimeout(() => {
                currentShapeIndex = (currentShapeIndex + 1) % 5;
                generateShape(currentShapeIndex);
            }, 500);
        }

        // --- GUI ---
        function setupGUI() {
            const gui = new lil.GUI({ container: document.getElementById('gui-container'), title: 'SYSTEM_CONTROLS' });
            
            // Config specific for Non-collapsible requirement
            // We use CSS to hide the close button and disable title click
            
            const folder = gui.addFolder('PARTICLE_ENGINE');
            folder.add(CONFIG, 'particleSize', 0.01, 1.0).name('Size').onChange(v => material.uniforms.uSize.value = v * 50);
            folder.add(CONFIG, 'glowIntensity', 0.0, 2.0).name('Glow');
            folder.open(); // Default open

            const interact = gui.addFolder('PHYSICS_FIELD');
            interact.add(CONFIG, 'repulseRadius', 0.5, 5.0).name('Field Radius').onChange(v => material.uniforms.uRepulseRadius.value = v);
            interact.add(CONFIG, 'repulseStrength', 1.0, 10.0).name('Repel Force').onChange(v => material.uniforms.uRepulseStrength.value = v);
            interact.open();

            const debug = gui.addFolder('DEBUG');
            debug.add({ next: () => triggerExplosion() }, 'next').name('>> NEXT MODEL');
            debug.open();
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            if (material) {
                material.uniforms.uTime.value = time;
                material.uniforms.uHandPos.value.lerp(handPosition, 0.1);
                if (isExploding) {
                    explosionTime += 0.025;
                    material.uniforms.uExplosion.value = Math.sin(explosionTime * Math.PI); 
                    if (explosionTime >= 1.0) { isExploding = false; material.uniforms.uExplosion.value = 0; }
                }
            }
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            resizeCanvas(); // Resize 2D canvas
            if (material) material.uniforms.uPixelRatio.value = renderer.getPixelRatio();
        }

        init();
    </script>
</body>
</html>
