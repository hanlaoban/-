<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Interactive Cosmic Vortex - Hand Tracking</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(120, 200, 255, 0.8);
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        #current-shape {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            margin-top: 5px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
        }
        #status {
            margin-top: 5px;
            font-size: 12px;
            color: #ffaa00;
        }
        /* éšè—è§†é¢‘å…ƒç´ ï¼Œæˆ‘ä»¬ä¸éœ€è¦çœ‹åˆ°å®ƒ */
        .input_video { display: none; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="info">
        COSMIC MATHEMATICS VISUALIZER<br>
        <div id="current-shape">INITIALIZING SYSTEM...</div>
        <div id="status">Waiting for camera permission... Show your hands! ğŸ‘</div>
    </div>

    <video class="input_video"></video>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ==========================================
        // --- MediaPipe æ‰‹åŠ¿è¯†åˆ«é›†æˆ ---
        // ==========================================
        const videoElement = document.getElementsByClassName('input_video')[0];
        const statusElement = document.getElementById('status');
        
        // äº¤äº’çŠ¶æ€å˜é‡
        let targetHandScale = 1.0; // ç›®æ ‡ç¼©æ”¾å€¼ï¼ˆåŸºäºå½“å‰æ£€æµ‹ï¼‰
        let smoothedHandScale = 1.0; // å¹³æ»‘åçš„ç¼©æ”¾å€¼ï¼ˆç”¨äºæ¸²æŸ“ï¼‰
        let handsDetected = false;

        // è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»çš„è¾…åŠ©å‡½æ•°
        function getDistance(p1, p2) {
            return Math.hypot(p1.x - p2.x, p1.y - p2.y);
        }

        // MediaPipe ç»“æœå›è°ƒå‡½æ•°
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handsDetected = true;
                statusElement.innerText = "Hands detected! Open/Close to scale.";
                statusElement.style.color = "#00ff00";

                let totalOpenness = 0;

                // éå†æ£€æµ‹åˆ°çš„æ¯åªæ‰‹ï¼ˆæœ€å¤š2åªï¼‰
                for (const landmarks of results.multiHandLandmarks) {
                    // æ‰‹è…•ç‚¹ç´¢å¼•æ˜¯ 0
                    const wrist = landmarks[0];
                    // æŒ‡å°–ç´¢å¼•ï¼šå¤§æ‹‡æŒ‡4, é£ŸæŒ‡8, ä¸­æŒ‡12, æ— åæŒ‡16, å°æŒ‡20
                    const fingertips = [4, 8, 12, 16, 20];
                    
                    let handAvgDist = 0;
                    for (let tipIndex of fingertips) {
                        // è®¡ç®—æŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»ã€‚æ³¨æ„ MediaPipe è¿”å›çš„æ˜¯å½’ä¸€åŒ–åæ ‡(0-1)
                        handAvgDist += getDistance(wrist, landmarks[tipIndex]);
                    }
                    handAvgDist /= fingertips.length;
                    totalOpenness += handAvgDist;
                }

                // è®¡ç®—å¹³å‡å¼ å¼€åº¦ (å¦‚æœæ£€æµ‹åˆ°ä¸¤åªæ‰‹)
                const avgOpenness = totalOpenness / results.multiHandLandmarks.length;

                // --- æ˜ å°„é€»è¾‘ ---
                // æ ¹æ®ç»éªŒï¼Œé—­åˆæ—¶ avgOpenness çº¦ä¸º 0.15-0.2ï¼Œå¼ å¼€æ—¶çº¦ä¸º 0.4-0.5
                // æˆ‘ä»¬å°†å…¶æ˜ å°„åˆ° 0.5å€ (é—­åˆ) åˆ° 3.0å€ (å¼ å¼€) çš„ç¼©æ”¾èŒƒå›´
                // ä½¿ç”¨ç®€å•çš„çº¿æ€§æ˜ å°„å’Œé’³ä½(clamp)
                const minOpen = 0.15;
                const maxOpen = 0.45;
                const minScale = 0.5;
                const maxScale = 3.0;

                // å½’ä¸€åŒ–å¼ å¼€åº¦ (0.0 - 1.0)
                let normalizedOpen = (avgOpenness - minOpen) / (maxOpen - minOpen);
                normalizedOpen = Math.max(0, Math.min(1, normalizedOpen)); // Clamp

                // æ˜ å°„åˆ°ç›®æ ‡ç¼©æ”¾
                targetHandScale = minScale + normalizedOpen * (maxScale - minScale);

            } else {
                handsDetected = false;
                statusElement.innerText = "No hands detected. Resetting scale.";
                statusElement.style.color = "#ffaa00";
                // å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°æ‰‹ï¼Œç¼“æ…¢æ¢å¤åˆ°é»˜è®¤å¤§å°
                targetHandScale = 1.0;
            }
        }

        // åˆå§‹åŒ– MediaPipe Hands
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        // åˆå§‹åŒ–æ‘„åƒå¤´
        const cameraWebcam = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640, // é™ä½åˆ†è¾¨ç‡ä»¥æé«˜æ€§èƒ½
            height: 480
        });
        cameraWebcam.start().catch(err => {
            statusElement.innerText = "Camera Error: " + err.message;
            statusElement.style.color = "red";
        });


        // ==========================================
        // --- Three.js æ ¸å¿ƒç³»ç»Ÿ (åŸºäºä¹‹å‰ä»£ç ) ---
        // ==========================================
        
        // --- é…ç½®å‚æ•° ---
        const CONFIG = {
            particleCount: 30000,
            particleSize: 0.15,
            autoChangeInterval: 8000, // ç¨å¾®å»¶é•¿åˆ‡æ¢æ—¶é—´ä»¥ä¾¿äº’åŠ¨
            colors: [0x00ffff, 0xff00ff, 0x4444ff, 0xffaa00, 0x00ffaa]
        };

        // --- åˆå§‹åŒ–åœºæ™¯ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 90;
        camera.position.y = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- æ§åˆ¶å™¨ ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5; // å‡æ…¢è‡ªåŠ¨æ—‹è½¬é€Ÿåº¦ï¼Œé˜²æ­¢å¹²æ‰°äº’åŠ¨ä½“éªŒ

        // --- åå¤„ç† (è¾‰å…‰æ•ˆæœ) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.15;
        bloomPass.strength = 1.3;
        bloomPass.radius = 0.6;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- ç²’å­ç³»ç»Ÿæ„å»º ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        // åŸºç¡€ç›®æ ‡ä½ç½®ï¼ˆä¸å«äº¤äº’ç¼©æ”¾ï¼‰
        const baseTargetPositions = new Float32Array(CONFIG.particleCount * 3); 
        const colors = new Float32Array(CONFIG.particleCount * 3);

        const colorObj = new THREE.Color();
        
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const colorType = i % CONFIG.colors.length;
            colorObj.setHex(CONFIG.colors[colorType]);
            colorObj.offsetHSL(0, 0, (Math.random() - 0.5) * 0.3); // å¢åŠ æ›´å¤šé¢œè‰²éšæœºæ€§

            colors[i * 3] = colorObj.r;
            colors[i * 3 + 1] = colorObj.g;
            colors[i * 3 + 2] = colorObj.b;

            positions[i * 3] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: CONFIG.particleSize,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.85
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- æ•°å­¦å…¬å¼åº“ (è®¾ç½®åˆ° baseTargetPositions) ---
        function setPos(i, x, y, z) {
            const jitter = 0.5; // å¢åŠ ä¸€ç‚¹æŠ–åŠ¨ï¼Œä½¿ç»“æ„çœ‹èµ·æ¥æ›´æ¾æ•£ã€æ›´æœ‰æœº
            baseTargetPositions[i * 3] = x + (Math.random() - 0.5) * jitter;
            baseTargetPositions[i * 3 + 1] = y + (Math.random() - 0.5) * jitter;
            baseTargetPositions[i * 3 + 2] = z + (Math.random() - 0.5) * jitter;
        }

        const shapes = [
             {
                name: "Lorenz Chaos Attractor",
                isIterative: true,
                iterativeFunc: () => {
                    let x = 1, y = 1, z = 1;
                    const dt = 0.006;
                    const sigma = 10, rho = 28, beta = 8/3;
                    const scale = 1.2;
                    for(let i=0; i<CONFIG.particleCount; i++) {
                        const dx = sigma * (y - x) * dt;
                        const dy = (x * (rho - z) - y) * dt;
                        const dz = (x * y - beta * z) * dt;
                        x += dx; y += dy; z += dz;
                        // åç§»ä¸­å¿ƒç‚¹ä»¥ä¾¿è§‚å¯Ÿ
                        setPos(i, x * scale, (y * scale) - 10, (z * scale) - 30); 
                    }
                }
            },
            {
                name: "Cardioid 3D",
                gen: (i) => {
                    const t = (i / CONFIG.particleCount) * Math.PI * 30;
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    const z = (Math.random() - 0.5) * 15 * Math.sin(t/2); // å¢åŠ Zè½´åšåº¦
                    const scale = 1.8;
                    setPos(i, x * scale, y * scale, z);
                }
            },
            {
                name: "Butterfly Curve Complex",
                gen: (i) => {
                    const t = (i / CONFIG.particleCount) * 30 * Math.PI; 
                    const e = Math.E;
                    const part1 = Math.pow(e, Math.sin(t));
                    const part2 = 2 * Math.cos(4 * t);
                    const part3 = Math.pow(Math.sin((2 * t - Math.PI) / 24), 5);
                    const r = part1 - part2 + part3;
                    const scale = 10;
                    // èºæ—‹å¼ Z è½´åˆ†å¸ƒ
                    setPos(i, r * Math.cos(t) * scale, r * Math.sin(t) * scale, Math.sin(t*0.5) * 30);
                }
            },
            {
                name: "Torus Knot (Interstellar Path)",
                gen: (i) => {
                     const t = (i / CONFIG.particleCount) * Math.PI * 2 * 5; // 5åœˆ
                     const p = 2, q = 3; // p, q å‚æ•°å†³å®šç»“çš„å½¢çŠ¶
                     const scale = 15;
                     const r = Math.cos(q * t) + 2;
                     const x = r * Math.cos(p * t) * scale;
                     const y = r * Math.sin(p * t) * scale;
                     const z = -Math.sin(q * t) * scale * 1.5;
                     setPos(i, x, y, z);
                }
            },
            {
                name: "Spherical Rose",
                gen: (i) => {
                    // ä½¿ç”¨çƒåæ ‡ç³»æ„å»º
                    const theta = Math.acos(2 * Math.random() - 1);
                    const phi = 2 * Math.PI * Math.random();
                    const k = 6; // èŠ±ç“£å‚æ•°
                    // åŠå¾„åŸºäºè§’åº¦å˜åŒ–
                    const r = 35 * (0.5 + 0.5 * Math.sin(k * phi) * Math.sin(k * theta));
                    setPos(i, 
                        r * Math.sin(theta) * Math.cos(phi),
                        r * Math.sin(theta) * Math.sin(phi),
                        r * Math.cos(theta)
                    );
                }
            }
        ];

        // --- åŠ¨ç”»çŠ¶æ€ç®¡ç† ---
        let currentShapeIndex = 0;
        const domTitle = document.getElementById('current-shape');

        function generateTargetShape(index) {
            const shape = shapes[index];
            domTitle.innerText = shape.name.toUpperCase();
            if (shape.isIterative) {
                shape.iterativeFunc();
            } else {
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    shape.gen(i);
                }
            }
        }

        generateTargetShape(0);
        setInterval(() => {
            currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
            generateTargetShape(currentShapeIndex);
        }, CONFIG.autoChangeInterval);

        // --- æ ¸å¿ƒæ¸²æŸ“å¾ªç¯ (æ•´åˆäº¤äº’) ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            // 1. äº¤äº’å¹³æ»‘å¤„ç†
            // ä½¿ç”¨ Lerp ä½¿ç¼©æ”¾å˜åŒ–éå¸¸å¹³æ»‘ï¼Œé¿å…æ‰‹åŠ¿æŠ–åŠ¨é€ æˆè§†è§‰ä¸é€‚
            // 0.05 æ˜¯ä¸€ä¸ªå¾ˆå°çš„ç³»æ•°ï¼Œæ„å‘³ç€å®ƒååº”è¾ƒæ…¢ä½†éå¸¸å¹³æ»‘
            smoothedHandScale += (targetHandScale - smoothedHandScale) * 0.05;

            // 2. ç²’å­ä½ç½®æ’å€¼
            const positionsArr = geometry.attributes.position.array;
            const lerpFactor = 0.04; 

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const px = positionsArr[i * 3];
                const py = positionsArr[i * 3 + 1];
                const pz = positionsArr[i * 3 + 2];

                // å…³é”®ä¿®æ”¹ï¼šè·å–åŸºç¡€ç›®æ ‡ä½ç½®ï¼Œç„¶åä¹˜ä»¥å½“å‰çš„å¹³æ»‘æ‰‹åŠ¿ç¼©æ”¾å› å­
                const tx = baseTargetPositions[i * 3] * smoothedHandScale;
                const ty = baseTargetPositions[i * 3 + 1] * smoothedHandScale;
                const tz = baseTargetPositions[i * 3 + 2] * smoothedHandScale;

                // ç®€å•çš„è·ç¦»åˆ¤æ–­ä¼˜åŒ–ï¼Œå‡å°‘ä¸å¿…è¦çš„è®¡ç®—
                if (Math.abs(px - tx) > 0.05 || Math.abs(py - ty) > 0.05 || Math.abs(pz - tz) > 0.05) {
                    positionsArr[i * 3] += (tx - px) * lerpFactor;
                    positionsArr[i * 3 + 1] += (ty - py) * lerpFactor;
                    positionsArr[i * 3 + 2] += (tz - pz) * lerpFactor;
                }
            }
            geometry.attributes.position.needsUpdate = true;

            // 3. æ•´ä½“åŠ¨æ€
            const time = clock.getElapsedTime();
            // æ—‹è½¬é€Ÿåº¦ä¹Ÿä¼šå—åˆ°æ‰‹åŠ¿å¼ å¼€ç¨‹åº¦çš„è½»å¾®å½±å“ï¼Œå¼ å¾—è¶Šå¼€è½¬å¾—è¶Šæ…¢
            const rotationSpeedFactor = 1.2 - (smoothedHandScale - 1) * 0.2; 
            particles.rotation.y = time * 0.04 * rotationSpeedFactor;
            particles.rotation.z = time * 0.015;

            // 4. æ¸²æŸ“
            controls.update();
            composer.render();
        }

        // --- çª—å£è‡ªé€‚åº” ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
